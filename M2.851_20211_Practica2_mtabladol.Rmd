---
title: 'Tipología y ciclo de vida de los datos: Práctica 2'
author: "Autor: Miguel Tablado"
date: "Junio 2022"
output:
  pdf_document:
    highlight: zenburn
    toc: yes
  word_document: default
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
    includes:
      in_header: 75.584-PEC-header.html
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Descripción del *dataset*. ¿Por qué es importante y qué pregunta/problema pretende responder?

He decidido trabajar con el dataset del vino porque fue un ejemplo parecido el que, a finales de 2020, en el periodo de vacaciones por Navidad, un caso parecido me ayudó a dar el paso de matricularme en el máster. Por aquel entonces, parte del tiempo de toma de decisión lo dediqué a explorar casos de uso expuestos en internet y recuerdo un caso de la plataforma de Google donde se exponía como precedir el precio de un vino en función del texto de la etiqueta, encontrando los tipos de uva y varias palabras clave. Este caso me recuerda a ese momento, y quiero ver qué similitudes y diferencias podré encontrar con aquel caso de demostración.

En un análisis rápido de, me parecen interesantes poder tomar para la clasificación y predicción la calidad del vino a partir de las diferentes propiedades del mismo. Sin duda, el objetivo del dataset es poder predecir la calidad del vino a partir de sus propiedades, seguramente a partir de regresiones, pero también podrían hacerse agrupaciones y otros métodos como los árboles de decisión.

Podemos ver que es un *dataset* potente con un número elevado de dimensiones y datos suficientes para cumplir con los requisitos de la práctica. Comprobaremos la calidad de los datos aquí, pero en un análisis rápido de kaggle, en la sección \"Column\" podemos ver que no hay datos perdidos ni erróneos, por tanto, a priori estamos ante un dataset con un conjunto de datos de calidad.

```{r message=FALSE, warning=FALSE}
# Cargamos las librerías necesarias para el ejercicio.
if (!require('ggplot2')) install.packages('ggplot2')
library('ggplot2')

if (!require('corrplot')) install.packages('corrplot')
library('corrplot')

# Carga del fichero y muestra inicial de campos.
df_red<-read.csv("winequality-red.csv", header=TRUE, sep=",")
str(df_red)
```

```{r}
summary(df_red)
```
## Integración y selección de los datos de interés a analizar. Puede ser el resultado de adicionar diferentes datasets o una subselección útil de los datos originales, en base al objetivo que se quiera conseguir

En la página de Kaggle se cita:

> The two datasets are related to red and white variants of the Portuguese "Vinho Verde" wine. For more details, consult the reference [Cortez et al., 2009].

Por tanto, he buscado en Kaggle el dataset del vino blanco (https://www.kaggle.com/datasets/piyushagni5/white-wine-quality), que se muestra a continuación:

```{r message=FALSE, warning=FALSE}
# Carga del fichero y muestra inicial de campos.
df_white<-read.csv("winequality-white.csv", header=TRUE, sep=";")
str(df_white)
```

Ambos datasets son extractos de un dataset original que agrupa los registros los diferencia mediante una variable `type` con valores `red` y `white` para los vinos tintos y blancos respectivamente.

En este ejercicico, en lugar de descargar el dataset original, fusionaremos ambos datasets buscando la misma estructura que en el dataset original, con el objetivo de comprobar las tareas de fusión.

Es relevante la importancia de hacer este procedimiento para obtener una información más amplía que nos permita verificar diferencias entre los tipos de vino y cómo sus variables ofrecen o no diferencias de calidad según el tipo de vino, es decir, analizar la relación entre el tipo y el resto de variables y la calidad final.

```{r}
df_red$type <- "red"
df_white$type <- "white"
df = rbind(df_red, df_white)
df$type <- as.factor(df$type)
summary(df)
```

En este caso, es obvio que, en lugar de seleccionar un subconjunto de vinos, lo que hemos hecho es fusionar porque nuestro objetivo es determinar la calidad de cualquier vino. Una vez fusionados vinos blancos y vinos tintos, podríamos seleccionar los vinos de un determinado rango de calidad, por ejemplo, los vinos excelentes. Sin embargo, se entiende que dejar fuera un conjunto de vinos nos llevaría a conclusiones que podrían no ser verdad.

Antes de continuar, lo primero que haremos será estandarizar el nombre de las columnas, sustituyendo los puntos por guiones
bajos, para facilitar el trabajo posterior con estas variables.


```{r}
colnames(df) <- c("fixed_acidity", "volatile_acidity", "citric_acid",
                  "residual_sugar", "chlorides", "free_sulfur_dioxide",
                  "total_sulfur_dioxide", "density", "pH", "sulphates",
                  "alcohol", "quality", "type")
```

## Limpieza de los datos

### ¿Los datos contienen ceros o elementos vacíos? Gestiona cada uno de estos casos.

Estadísticas de valores vacíos:

```{r}
colSums(is.na(df))
colSums(df=="")
```

Podemos apreciar que no hay ningún dato nulo o vacío con lo que estamos ante un conjunto de datos de muy buena calidad. 

### Identifica y gestiona los valores extremos

Buscando información para poder interpretar los diferentes *outliers*, he encontrado un artículo interesante que habla de los diferentes tipos de cítricos que pueden existir en un vino y cómo las diferentes condiciones de cultivo y tipo de uva influyen en los valores de los mismos.

Es por eso, que no soy capaz de determinar si estos valores deben ser corregidos (ningún valor digamos químico). Por tanto, en lugar de corregir los valores, simplemente mostraré un diagrama de cajas para cada uno de ellos y un histograma en aquellos donde la interpretación de los cuartiles nos lleve a pensar que no hay una distribución normal. 

Ref: https://waterhouse.ucdavis.edu/whats-in-wine/fixed-acidity

```{r}
boxplot(df$fixed_acidity, main="Fixed Acidity Boxplot", horizontal = TRUE)
```
```{r}
boxplot(df$volatile_acidity, main="Volatile Acidity Boxplot", horizontal = TRUE)
```
```{r}
boxplot(df$citric_acid, main="Citric Acid Boxplot", horizontal = TRUE)
```
```{r}
boxplot(df$residual_sugar, main="Residual Sugar Boxplot", horizontal = TRUE)
```
```{r}
boxplot(df$chlorides, main="Chlorides Boxplot", horizontal = TRUE)
hist(df$chlorides, xlab = "Chlorides", main = "Chlorides Histogram")
```
```{r}
boxplot(df$free_sulfur_dioxide, main="Free Sulfur Dioxide Boxplot", horizontal = TRUE)
hist(df$free_sulfur_dioxide, xlab = "Free Sulfur", main = "Free Sulfur Histogram")
```
```{r}
boxplot(df$total_sulfur_dioxide, main="Total Sulfur Dioxide Boxplot", horizontal = TRUE)
```

```{r}
boxplot(df$pH, main="PH Boxplot", horizontal = TRUE)
```
```{r}
boxplot(df$sulphates, main="Sulphates Boxplot", horizontal = TRUE)
```
```{r}
boxplot(df$alcohol, main="Alcohol Boxplot", horizontal = TRUE)
```

En el caso del Alcohol, sí podemos saber que hay vinos que pueden dar porcentajes como los valores que tenemos en el dataset, por lo que no corregimos estos datos.

```{r}
boxplot(df$density, main="Density Boxplot", horizontal = TRUE)
```

La densidad del vino debe ser un poco inferior a 1, que es la densidad del agua. Aunque el zumo de uva es claramente superior en densidad al agua, el proceso de fermentación lo reduce, debiendo este ser algo inferior a 1. Por tanto, en este caso, corregiremos los valores de densidad superior a 1, marcando la media como valor del vino. Aunque esos valores pudieran ser válidos por un mal proceso de fermentación, claro está, haremos la conversión igualmente.

```{r}
df$density[df$density > 1] <- 1
summary(df$density)
boxplot(df$density, main="Density Boxplot", horizontal = TRUE)
```
## Análisis de los datos.

### Selección de los grupos de datos que se quieren analizar/comparar (p. e., si se van a comparar grupos de datos, ¿cuáles son estos grupos y qué tipo de análisis se van a aplicar?)

En primer lugar, dado el número de variables que tiene nuestro conjunto de datos, vamos a realizar un análisis de la correlación entre estas variables, a ver si podemos determinar que alguna sea explicable a partir de otra.

*Correlaciones con mapas de calor* Trabajaremos con un nuevo data frame para utilizar las funciones cor y corrplot que nos permitirán mostrar un mapa de calor de las correlaciones existentes en los datos. Este df necesitará tener los datos del tipo de vino en modo numérico, con lo que deberemos transformarlo y comprobar sus valores.

```{r}
cor_df <- data.frame(df)
cor_df$type <- as.numeric(cor_df$type)
```

Hemos comprobado que la función *as.numeric* ha asignado los valores 1 y 2 para los vinos tintos y blancos respectivamente. El gráfico de barras es en este caso mejor que un resumen de los datos que nos mostraría valores estadísticos que no nos dejarían verificar que solamente existiesen valores discretos.

```{r}
cc = cor(cor_df, method = "spearman")
corrplot(cc)
```

En el gráfico podemos ver relaciones fuertes entre múltiples valores como por ejemplo entre la densidad y el alcohol, pero, es seguramente más relevante encontrar las relaciones para los tipos de vino. Empecemos con el vino tinto.

```{r}
dfw <- data.frame(
  cor_df[cor_df$type==1, ])
dfw <- subset(dfw, select = -c(type))

cc = cor(dfw, method = "spearman")
corrplot(cc, order = "hclust", hclust.method = "average")
```

Las relaciones encontradas en el mapa de calor para el **vino tinto** son:

- Ácido y pH, a medida que uno aumenta, el otro disminuye dado que tienen correlaciones negativas. En concreto, el pH y el ácido fijo tienen una relación muy alta y permiten una predicción perfecta el uno en base al otro
- Ácido cítrico y ácido fijo, están relacionados positivamente, lo que significa que cuando aumenta uno, también lo hace el otro y tienen una correlación bastante alta, permitiendo un nivel de predictibilidad interesante. 
- Los valores que más influyen en la calidad son el ácido, los sulfatos y el alcohol, donde el primero la reduce, los otros la mejoran.

```{r}
dfw <- data.frame(
  cor_df[cor_df$type==2, ])
dfw <- subset(dfw, select = -c(type))

cc = cor(dfw, method = "spearman")
corrplot(cc)

```

Las relaciones encontradas en el mapa de calor para el **vino blanco** son:

- Densidad y alcohol: correlación negativa y con muy buenas opciones de predicción.
- Azúcar y densidad: correlación positiva y valor cercano a 1
- Azúcar y alcohol: correlación negativa, como es lógico por la regla de tres que se puede establecer dadas las relaciones anteriores.
- También se puede ver que, en cuanto al vino blanco se refiere, a mayor alcohol mayor calidad y que este es el elemento más destacado en cuanto a la calidad se refiere

Dado que los datos a analizar varían claramente entre los vinos tintos y los vinos blancos, para este ejercicio, utilizaremos los datos de los vinos tintos (dado que son los datos originales del ejercicio):

- Ácido Fijo
- Ácido Cítrico
- Alcohol
- Calidad del vino

## Comprobación de la normalidad y homogeneidad de la varianza.

Anteriormente hemos analizado con *boxplots* los valores *outliers* y hemos podido ver cómo algunos de los valores no se repartían de forma normal, ya que la línea divisoria dentro de la caja, se ve claramente decantada hacia algún cuartil. Adicionalmente, utilizaremos métodos paramétricos para verificar la normalidad de los atributos seleccionados. Para ello utilizarmos la prueba de Shapiro-Wilk.

### Comprobación de normalidad

```{r}
shapiro.test(df_red$fixed.acidity)
```

```{r}
shapiro.test(df_red$volatile.acidity)
```

```{r}
shapiro.test(df_red$alcohol)
```

```{r}
shapiro.test(df_red$quality)
```
Podemos observar que, en todos los casos el valor p es menor al valor de significancia 0.05, con lo que se rechaza la hipotesis nula que supone que los datos están distribuidos normalmente.

Veámos un ejemplo gráfico que ayudará visualmente a contrastar la prueba de shapiro.

```{r}
qqnorm(df_red$alcohol)
qqline(df_red$alcohol)
```

### Comprobación de homocedasticidad

Dado que los atributos a revisar no siguen distribución normal, utilizaremos la prueba de Fligner-Killeen.

```{r}
fligner.test(fixed.acidity ~ volatile.acidity, data = df_red)
```

Dado que el p-valor es menor que el valor de significancia, se rechaza la hipotesis nula de homocedasticidad y se concluye las variables `fixed.acidity` y `volatile.acidity` presentan varianzas estadísiticas entre sus diferentes grupos.

```{r}
fligner.test(alcohol ~ quality, data = df_red)
```
Dado que el p-valor es menor que el valor de significancia, se rechaza la hipotesis nula de homocedasticidad y se concluye las variables `alcohol` presenta varianzas estadísiticas para las diferentes calidades `quality`.

### Aplicación de pruebas estadísticas para comparar los grupos de datos. En función de los datos y el objetivo del estudio, aplicar pruebas de contraste de hipótesis, correlaciones, regresiones, etc. Aplicar al menos tres métodos de análisis diferentes.

Dado que las pruebas de los datos han demostrado que las variables no siguen una distribución normal y que presentan heterocedasticidad, aplicaremos pruebas de correlacion de Spearman.

Aplicaremos también regresiones entre los ácidos y el alcohol y la calidad del vino.

```{r}
lm(fixed.acidity ~ volatile.acidity, data = df_red)
cor.test(df_red$fixed.acidity, df_red$volatile.acidity, method="spearman")
```
```{r}
lm(alcohol ~ quality, data = df_red)
cor.test(df_red$alcohol, df_red$quality, method="spearman")
```
Por último, realizaremos la comprobación entre los grupos de Kruskal, que es una alternativa no paramétrica. Para hacerlo más visual, lo haremos solamente con las variables alcohol y calidad del vino, pero antes, crearemos grupos de calidad de vino de la siguiente manera:

- Malo: 0 a 3
- Regular: 4 a 5
- Bueno: 6 a 7
- Muy bueno: 8 a 10

```{r}
quality_df <- data.frame(df_red)
quality_df["quality_segment"] <- cut(quality_df$quality, breaks = c(0,4,6,8,10), labels = c("0-3", "4-5", "6-7", "8-10"))
ggplot(quality_df, aes(x=quality_segment, fill=type)) +
  geom_bar() +
  labs(x = "Calidad", y = "Total", fill = "Tipo de Vino", title = "Calidad de vino")
```

Ahora ejecutamos la prueba.

```{r}
kruskal.test(alcohol ~ quality, data = quality_df )
```
Dado que el p-valor obtenido es menor al nivel de significancia, se puede concluir que el alcohol muestra diferencias significativas para los diferentes rangos de calidad del vino.

## Resolución

Analizando los datos y las comprobaciones llevadas a cabo, no podemos resolver el problema de saber cuál será la calidad del vino a partir de sus propiedades. Los motivos principales son:

- Falta de conocimiento de los valores químicos presentes en un vino por mi parte.
- Falta de profundidad en el análisis. Hemos analalizados todas las variables y trabajado en determinar la relación de la calidad solamente con el alcohol, lo cual es insuficiente para resolver el problema. En los mapas de calor de las correlaciones, no se apreció una relación fuerte/directa para trabajar en la comparación con solamente 2 grupos y se requiere de un análisis más exhaustivo y completo
- Las muestras de vinos no están balanceadas y presentan mucho vinos normales, muy pocos peores y ningún vino excelente.

Por otra parte, hemos podido observar la dificultad de trabajar con este tipo de datos ya que no siguen distribuciones normales, si bien, los datos son de calidad. 

## Video

El video explicativo puede descargarse de en este enlace: https://drive.google.com/file/d/1yFRLmDb-I3fdxxE-dpiU4up2tkHrnlcY/view?usp=sharing

## Contribuciones

| Contribuciones                       | Firma |
|--------------------------------------|-------|
| Descripción del dataset.             | MTL   |
| Integración y selección de los datos | MTL   |
| Limpieza de los datos                | MTL   |
| Análisis de los datos                | MTL   |
| Representación                       | MTL   |
| Resolución                           | MTL   |
| Código                               | MTL   |

